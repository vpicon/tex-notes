\begin{mysection}{Sorting in Linear Time}

\subsection{Lower bounds for sorting}
    So far we have been studying only \concept{comparison sorts}: they use only on comparisons between the input elements to gain order informatino about an input sequence $\left( a_1, a_2, \dotsc, a_n \right)$. We will assume, without loss of generality, that all the input elements are distinct.
    
    So, given two elements $a_i$ and $a_j$, we perform one of the tests $a_i < a_j$, $a_i \leq a_j$, $a_i > a_j$, $a_i \geq a_j$, to determine their relative order. Assuming distinct elements, all these operations yield identical information about relative order of $a_i$ and $a_j$. Hence assume that all the comparisons are of the form $a_i \leq a_j$.

    \paragraph{Decision Tree.} We can view comparison sorts abstractly in terms of \concept{decision trees}, a full binary tree that represents the comparisons between elements that are performed by a particular sorting algorithm operating on an input of a given size.

    %INSERT FIGURE OF DECISION TREE

    In a decision tree, we annotate each internal node by $i:j$ for some $i$ and $j$ in the range $1 \leq i,j \leq n$, where $n$ is the number of elements in the input sequence. We also annotate each leaf by a permutation $\left( \sigma(1), \sigma(2), \dotsc, \sigma(n) \right)$. The execution of the sorting algorithm corresponds to \underline{tracing a simple path} \underline{from the root of the decision tree down to a leaf}. Each inernal node indicates a comparison $a_i \leq a_j$; the left subtree indicate the subsequent comparisons once we know that $a_i \leq a_j$, the right subtree the comparisons for the case $a_i > a_j$. When we arrive at a leaf, the algorithm has established an order $a_{\sigma(1)} \leq a_{\sigma(2)} \leq \dots \leq a_{\sigma(n)}$. 

    Because any sorting algorithm can produce any of the $n!$ permutations, each one of those permutations must appear as one of the leaves of the decision tree for a comparison sort to be correct. Furthermore, each of these leaves must be reachable from the root by a downward path corresponding to an actual execution of the comparison sort. Thus, considering only decision trees in which each permutation appears as a reachable leaf.

    \paragraph{Lower bound for the worst case.} The lenght of the longest simple path from the root of the decision tree to any of its reachable leaves, that is the height of the decision tree, represents the worst case number of comparisons that the corresponding sorting algorithm performs. A lower bound on the heights of all decision trees in which each permutation appears as a reachable leaf is therefore a lowe bound on the running time of any comparison sort algorithm. The theorem establishes such lower bound.

\begin{theorem}
    Any comparison sort algorithm requires $\Theta(n\log{n})$ comparisons on the worst case.
\end{theorem}
\begin{proof}
It suffices to determine the height of a decision tree in which each permutation appears as a reachable leaf. Consider a decision tree of height $h$ with $l$ reachable leaves corresponding to a comparison sort on $n$ elements. Because each of the $n!$ permutations of the input appears as some leaf, we have that $n! \leq l$. Since a binary tree of height $h$ has at most $2^h$ leaves, we have $n! \leq l \leq 2^h$, which implies $h \leq \log(n!) = \Omega(n\log{n})$.
\end{proof}

\begin{corollary}
    Heapsort and merge sort are asymptotically optimal comparison sorts.
\end{corollary}







\end{mysection}
